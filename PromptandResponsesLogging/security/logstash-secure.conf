input {
  file {
    path => "/usr/share/logstash/logs/llm_logs.json"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
    type => "llm_log"
  }
  
  # Optional: Accept logs via beats
  beats {
    port => 5044
  }
}

filter {
  if [type] == "llm_log" {
    # Parse the timestamp field
    date {
      match => ["timestamp", "ISO8601"]
    }
    
    # PII Redaction - Remove sensitive information
    mutate {
      # Create a copy of the original prompt for debugging if needed
      copy => { "prompt" => "original_prompt" }
      copy => { "response" => "original_response" }
    }
    
    # Redact common PII patterns
    ruby {
      code => "
        # Redact email addresses
        prompt = event.get('prompt')
        response = event.get('response')
        
        if prompt
          prompt = prompt.gsub(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/, '[EMAIL_REDACTED]')
          prompt = prompt.gsub(/\b\d{3}-\d{2}-\d{4}\b/, '[SSN_REDACTED]')
          prompt = prompt.gsub(/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/, '[CARD_REDACTED]')
          event.set('prompt', prompt)
        end
        
        if response
          response = response.gsub(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/, '[EMAIL_REDACTED]')
          response = response.gsub(/\b\d{3}-\d{2}-\d{4}\b/, '[SSN_REDACTED]')
          response = response.gsub(/\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/, '[CARD_REDACTED]')
          event.set('response', response)
        end
      "
    }
    
    # Remove original copies if PII redaction is complete
    mutate {
      remove_field => ["original_prompt", "original_response"]
    }
    
    # Add computed fields for analytics
    ruby {
      code => "
        prompt = event.get('prompt')
        response = event.get('response')
        
        if prompt
          event.set('prompt_length', prompt.length)
        end
        
        if response
          event.set('response_length', response.length)
        end
        
        prompt_len = event.get('prompt_length') || 0
        response_len = event.get('response_length') || 0
        event.set('total_length', prompt_len + response_len)
        
        # Add hour of day for time-based analysis
        event.set('hour_of_day', Time.parse(event.get('timestamp')).hour)
        
        # Add day of week
        event.set('day_of_week', Time.parse(event.get('timestamp')).strftime('%A'))
      "
    }
    
    # Convert numeric fields
    if [tokens_used] {
      mutate {
        convert => { "tokens_used" => "integer" }
      }
    }
    
    if [latency_ms] {
      mutate {
        convert => { "latency_ms" => "float" }
      }
    }
    
    # Add performance categories
    if [latency_ms] {
      if [latency_ms] < 100 {
        mutate { add_field => { "performance_category" => "fast" } }
      } else if [latency_ms] < 500 {
        mutate { add_field => { "performance_category" => "normal" } }
      } else if [latency_ms] < 1000 {
        mutate { add_field => { "performance_category" => "slow" } }
      } else {
        mutate { add_field => { "performance_category" => "very_slow" } }
      }
    }
    
    # Add token usage categories
    if [tokens_used] {
      if [tokens_used] < 50 {
        mutate { add_field => { "token_category" => "light" } }
      } else if [tokens_used] < 200 {
        mutate { add_field => { "token_category" => "medium" } }
      } else if [tokens_used] < 500 {
        mutate { add_field => { "token_category" => "heavy" } }
      } else {
        mutate { add_field => { "token_category" => "very_heavy" } }
      }
    }
  }
}

output {
  elasticsearch {
    hosts => ["https://elasticsearch:9200"]
    index => "llm-logs-%{+YYYY.MM.dd}"
    user => "%{ELASTICSEARCH_USERNAME}"
    password => "%{ELASTICSEARCH_PASSWORD}"
    ssl => true
    cacert => "/usr/share/logstash/config/certs/ca/ca.crt"
    template_name => "llm-logs"
    template_pattern => "llm-logs-*"
    template => {
      "index_patterns" => ["llm-logs-*"],
      "settings" => {
        "number_of_shards" => 1,
        "number_of_replicas" => 0,
        "index.lifecycle.name" => "llm-logs-policy",
        "index.lifecycle.rollover_alias" => "llm-logs"
      },
      "mappings" => {
        "properties" => {
          "timestamp" => { "type" => "date" },
          "prompt" => { 
            "type" => "text", 
            "analyzer" => "standard",
            "fields" => {
              "keyword" => {
                "type" => "keyword",
                "ignore_above" => 256
              }
            }
          },
          "response" => { 
            "type" => "text", 
            "analyzer" => "standard",
            "fields" => {
              "keyword" => {
                "type" => "keyword",
                "ignore_above" => 256
              }
            }
          },
          "model" => { "type" => "keyword" },
          "user_id" => { "type" => "keyword" },
          "session_id" => { "type" => "keyword" },
          "tokens_used" => { "type" => "integer" },
          "latency_ms" => { "type" => "float" },
          "prompt_length" => { "type" => "integer" },
          "response_length" => { "type" => "integer" },
          "total_length" => { "type" => "integer" },
          "hour_of_day" => { "type" => "integer" },
          "day_of_week" => { "type" => "keyword" },
          "performance_category" => { "type" => "keyword" },
          "token_category" => { "type" => "keyword" },
          "prompt_category" => { "type" => "keyword" },
          "event_type" => { "type" => "keyword" },
          "error_type" => { "type" => "keyword" },
          "error_message" => { "type" => "text" }
        }
      }
    }
  }
  
  # Output to stdout for debugging (remove in production)
  stdout { 
    codec => rubydebug 
  }
}